//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { FetchBase } from '$lib/services/nswagApiBase';

export interface IUtilityClient {

    utility_GetTest(): Promise<FileResponse | null>;

    /**
     * @return A success message.
     */
    postUserRegistrationImport(): Promise<void>;
}

export class UtilityClient extends FetchBase implements IUtilityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    utility_GetTest(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/Utility";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUtility_GetTest(_response);
        });
    }

    protected processUtility_GetTest(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    /**
     * @return A success message.
     */
    postUserRegistrationImport(): Promise<void> {
        let url_ = this.baseUrl + "/Utility/Import";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostUserRegistrationImport(_response);
        });
    }

    protected processPostUserRegistrationImport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IAuth0Client {

    /**
     * @return A success message.
     */
    postPreRegistration(request: PreRegistrationRequest): Promise<PreRegistrationResponse>;

    /**
     * @return A success message.
     */
    postRegistration(request: PostRegistrationRequest): Promise<void>;
}

export class Auth0Client extends FetchBase implements IAuth0Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return A success message.
     */
    postPreRegistration(request: PreRegistrationRequest): Promise<PreRegistrationResponse> {
        let url_ = this.baseUrl + "/Auth0/PreRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostPreRegistration(_response);
        });
    }

    protected processPostPreRegistration(response: Response): Promise<PreRegistrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PreRegistrationResponse;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PreRegistrationResponse>(null as any);
    }

    /**
     * @return A success message.
     */
    postRegistration(request: PostRegistrationRequest): Promise<void> {
        let url_ = this.baseUrl + "/Auth0/PostRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostRegistration(_response);
        });
    }

    protected processPostRegistration(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IEquipmentClient {

    /**
     * @return A list of equipment groups.
     */
    getEquipmentGroups(): Promise<EquipmentGroupDto[]>;

    /**
     * @return A body area.
     */
    getEquipmentGroup(equipmentGroupId: EquipmentGroupTypes, bodyAreaId: string): Promise<EquipmentGroupDto>;
}

export class EquipmentClient extends FetchBase implements IEquipmentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return A list of equipment groups.
     */
    getEquipmentGroups(): Promise<EquipmentGroupDto[]> {
        let url_ = this.baseUrl + "/Equipment/EquipmentGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEquipmentGroups(_response);
        });
    }

    protected processGetEquipmentGroups(response: Response): Promise<EquipmentGroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EquipmentGroupDto[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EquipmentGroupDto[]>(null as any);
    }

    /**
     * @return A body area.
     */
    getEquipmentGroup(equipmentGroupId: EquipmentGroupTypes, bodyAreaId: string): Promise<EquipmentGroupDto> {
        let url_ = this.baseUrl + "/Equipment/BodyArea/{bodyAreaId}";
        if (equipmentGroupId === undefined || equipmentGroupId === null)
            throw new Error("The parameter 'equipmentGroupId' must be defined.");
        url_ = url_.replace("{equipmentGroupId}", encodeURIComponent("" + equipmentGroupId));
        if (bodyAreaId === undefined || bodyAreaId === null)
            throw new Error("The parameter 'bodyAreaId' must be defined.");
        url_ = url_.replace("{bodyAreaId}", encodeURIComponent("" + bodyAreaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetEquipmentGroup(_response);
        });
    }

    protected processGetEquipmentGroup(response: Response): Promise<EquipmentGroupDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EquipmentGroupDto;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EquipmentGroupDto>(null as any);
    }
}

export interface IExerciseClient {

    getFilteredExercises(request: GetFilteredExercisesRequest): Promise<void>;
}

export class ExerciseClient extends FetchBase implements IExerciseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getFilteredExercises(request: GetFilteredExercisesRequest): Promise<void> {
        let url_ = this.baseUrl + "/Exercise/FilteredExercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetFilteredExercises(_response);
        });
    }

    protected processGetFilteredExercises(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IMuscleClient {

    /**
     * @return A list of body areas.
     */
    getBodyAreas(): Promise<BodyAreaDto[]>;

    /**
     * @return A body area.
     */
    getBodyArea(bodyAreaId: BodyAreaTypes): Promise<BodyAreaDto>;

    /**
     * @return A list of muscle groups.
     */
    getMuscleGroups(): Promise<MuscleGroupDto[]>;

    /**
     * @return A muscle group.
     */
    getMuscleGroup(muscleGroupId: MuscleGroupTypes): Promise<MuscleGroupDto>;

    /**
     * @return A list of muscles.
     */
    getMuscles(): Promise<MuscleDto[]>;

    /**
     * @return A muscle.
     */
    getMuscle(muscleId: MuscleTypes): Promise<MuscleDto>;

    /**
     * @return A list of joints.
     */
    getJoints(): Promise<JointDto[]>;

    /**
     * @return A joint.
     */
    getJoint(jointId: JointTypes): Promise<JointDto>;
}

export class MuscleClient extends FetchBase implements IMuscleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return A list of body areas.
     */
    getBodyAreas(): Promise<BodyAreaDto[]> {
        let url_ = this.baseUrl + "/Muscle/BodyArea";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetBodyAreas(_response);
        });
    }

    protected processGetBodyAreas(response: Response): Promise<BodyAreaDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BodyAreaDto[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BodyAreaDto[]>(null as any);
    }

    /**
     * @return A body area.
     */
    getBodyArea(bodyAreaId: BodyAreaTypes): Promise<BodyAreaDto> {
        let url_ = this.baseUrl + "/Muscle/BodyArea/{bodyAreaId}";
        if (bodyAreaId === undefined || bodyAreaId === null)
            throw new Error("The parameter 'bodyAreaId' must be defined.");
        url_ = url_.replace("{bodyAreaId}", encodeURIComponent("" + bodyAreaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetBodyArea(_response);
        });
    }

    protected processGetBodyArea(response: Response): Promise<BodyAreaDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BodyAreaDto;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BodyAreaDto>(null as any);
    }

    /**
     * @return A list of muscle groups.
     */
    getMuscleGroups(): Promise<MuscleGroupDto[]> {
        let url_ = this.baseUrl + "/Muscle/MuscleGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMuscleGroups(_response);
        });
    }

    protected processGetMuscleGroups(response: Response): Promise<MuscleGroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MuscleGroupDto[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleGroupDto[]>(null as any);
    }

    /**
     * @return A muscle group.
     */
    getMuscleGroup(muscleGroupId: MuscleGroupTypes): Promise<MuscleGroupDto> {
        let url_ = this.baseUrl + "/Muscle/MuscleGroup/{muscleGroupId}";
        if (muscleGroupId === undefined || muscleGroupId === null)
            throw new Error("The parameter 'muscleGroupId' must be defined.");
        url_ = url_.replace("{muscleGroupId}", encodeURIComponent("" + muscleGroupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMuscleGroup(_response);
        });
    }

    protected processGetMuscleGroup(response: Response): Promise<MuscleGroupDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MuscleGroupDto;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleGroupDto>(null as any);
    }

    /**
     * @return A list of muscles.
     */
    getMuscles(): Promise<MuscleDto[]> {
        let url_ = this.baseUrl + "/Muscle/Muscle";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMuscles(_response);
        });
    }

    protected processGetMuscles(response: Response): Promise<MuscleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MuscleDto[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleDto[]>(null as any);
    }

    /**
     * @return A muscle.
     */
    getMuscle(muscleId: MuscleTypes): Promise<MuscleDto> {
        let url_ = this.baseUrl + "/Muscle/Muscle/{muscleId}";
        if (muscleId === undefined || muscleId === null)
            throw new Error("The parameter 'muscleId' must be defined.");
        url_ = url_.replace("{muscleId}", encodeURIComponent("" + muscleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMuscle(_response);
        });
    }

    protected processGetMuscle(response: Response): Promise<MuscleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MuscleDto;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleDto>(null as any);
    }

    /**
     * @return A list of joints.
     */
    getJoints(): Promise<JointDto[]> {
        let url_ = this.baseUrl + "/Muscle/Joints";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetJoints(_response);
        });
    }

    protected processGetJoints(response: Response): Promise<JointDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as JointDto[];
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JointDto[]>(null as any);
    }

    /**
     * @return A joint.
     */
    getJoint(jointId: JointTypes): Promise<JointDto> {
        let url_ = this.baseUrl + "/Muscle/Joint/{jointId}";
        if (jointId === undefined || jointId === null)
            throw new Error("The parameter 'jointId' must be defined.");
        url_ = url_.replace("{jointId}", encodeURIComponent("" + jointId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetJoint(_response);
        });
    }

    protected processGetJoint(response: Response): Promise<JointDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as JointDto;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("Unknown internal error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JointDto>(null as any);
    }
}

export interface IRoutineClient {

    /**
     * @return A success message.
     */
    deleteRoutine(routineId: string): Promise<void>;

    /**
     * @return A success message.
     */
    getRoutine(routineId: string): Promise<Routine>;

    /**
     * @return A success message.
     */
    patchRoutine(routineId: string, request: PatchRoutineRequest): Promise<Routine>;

    /**
     * @return A success message.
     */
    patchMoveRoutine(routineId: string, position: number): Promise<Routine[]>;

    /**
     * @return A success message.
     */
    postRoutine(workoutId: string, routineRequest: PostRoutineRequest): Promise<Routine>;
}

export class RoutineClient extends FetchBase implements IRoutineClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return A success message.
     */
    deleteRoutine(routineId: string): Promise<void> {
        let url_ = this.baseUrl + "/Routine/{routineId}";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRoutine(_response);
        });
    }

    protected processDeleteRoutine(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return A success message.
     */
    getRoutine(routineId: string): Promise<Routine> {
        let url_ = this.baseUrl + "/Routine/{routineId}";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoutine(_response);
        });
    }

    protected processGetRoutine(response: Response): Promise<Routine> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Routine;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Routine>(null as any);
    }

    /**
     * @return A success message.
     */
    patchRoutine(routineId: string, request: PatchRoutineRequest): Promise<Routine> {
        let url_ = this.baseUrl + "/Routine/{routineId}";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPatchRoutine(_response);
        });
    }

    protected processPatchRoutine(response: Response): Promise<Routine> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Routine;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Routine>(null as any);
    }

    /**
     * @return A success message.
     */
    patchMoveRoutine(routineId: string, position: number): Promise<Routine[]> {
        let url_ = this.baseUrl + "/Routine/{routineId}/Move/{position}";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        if (position === undefined || position === null)
            throw new Error("The parameter 'position' must be defined.");
        url_ = url_.replace("{position}", encodeURIComponent("" + position));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPatchMoveRoutine(_response);
        });
    }

    protected processPatchMoveRoutine(response: Response): Promise<Routine[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Routine[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Routine[]>(null as any);
    }

    /**
     * @return A success message.
     */
    postRoutine(workoutId: string, routineRequest: PostRoutineRequest): Promise<Routine> {
        let url_ = this.baseUrl + "/Workout/{workoutId}/Routine";
        if (workoutId === undefined || workoutId === null)
            throw new Error("The parameter 'workoutId' must be defined.");
        url_ = url_.replace("{workoutId}", encodeURIComponent("" + workoutId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(routineRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostRoutine(_response);
        });
    }

    protected processPostRoutine(response: Response): Promise<Routine> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Routine;
            return result201;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Routine>(null as any);
    }
}

export interface ISetClient {

    /**
     * @return A success message.
     */
    postSet(routineId: string, setRequest: PostSetRequest): Promise<Set>;

    /**
     * @return A success message.
     */
    deleteSet(setId: string): Promise<void>;

    /**
     * @return A success message.
     */
    getSet(setId: string): Promise<Set>;

    /**
     * @return A success message.
     */
    patchSet(setId: string, request: PatchSetRequest): Promise<Set>;

    /**
     * @return A success message.
     */
    patchSetMove(setId: string, position: number): Promise<Set[]>;
}

export class SetClient extends FetchBase implements ISetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return A success message.
     */
    postSet(routineId: string, setRequest: PostSetRequest): Promise<Set> {
        let url_ = this.baseUrl + "/Routine/{routineId}/Set";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostSet(_response);
        });
    }

    protected processPostSet(response: Response): Promise<Set> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Set;
            return result201;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Set>(null as any);
    }

    /**
     * @return A success message.
     */
    deleteSet(setId: string): Promise<void> {
        let url_ = this.baseUrl + "/Set/{setId}";
        if (setId === undefined || setId === null)
            throw new Error("The parameter 'setId' must be defined.");
        url_ = url_.replace("{setId}", encodeURIComponent("" + setId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSet(_response);
        });
    }

    protected processDeleteSet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return A success message.
     */
    getSet(setId: string): Promise<Set> {
        let url_ = this.baseUrl + "/Set/{setId}";
        if (setId === undefined || setId === null)
            throw new Error("The parameter 'setId' must be defined.");
        url_ = url_.replace("{setId}", encodeURIComponent("" + setId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSet(_response);
        });
    }

    protected processGetSet(response: Response): Promise<Set> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Set;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Set>(null as any);
    }

    /**
     * @return A success message.
     */
    patchSet(setId: string, request: PatchSetRequest): Promise<Set> {
        let url_ = this.baseUrl + "/Set/{setId}";
        if (setId === undefined || setId === null)
            throw new Error("The parameter 'setId' must be defined.");
        url_ = url_.replace("{setId}", encodeURIComponent("" + setId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPatchSet(_response);
        });
    }

    protected processPatchSet(response: Response): Promise<Set> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Set;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Set>(null as any);
    }

    /**
     * @return A success message.
     */
    patchSetMove(setId: string, position: number): Promise<Set[]> {
        let url_ = this.baseUrl + "/Set/{setId}/Move/{position}";
        if (setId === undefined || setId === null)
            throw new Error("The parameter 'setId' must be defined.");
        url_ = url_.replace("{setId}", encodeURIComponent("" + setId));
        if (position === undefined || position === null)
            throw new Error("The parameter 'position' must be defined.");
        url_ = url_.replace("{position}", encodeURIComponent("" + position));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPatchSetMove(_response);
        });
    }

    protected processPatchSetMove(response: Response): Promise<Set[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Set[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Set[]>(null as any);
    }
}

export interface IWorkoutClient {

    /**
     * @return A success message.
     */
    getWorkouts(userId: string): Promise<Workout[]>;

    /**
     * @return A success message.
     */
    postWorkout(userId: string, workoutRequest: PostWorkoutRequest): Promise<Workout>;

    /**
     * @return A success message.
     */
    deleteWorkout(workoutId: string): Promise<void>;

    /**
     * @return A success message.
     */
    getWorkout(workoutId: string): Promise<Workout>;

    /**
     * @return A success message.
     */
    patchWorkout(workoutId: string, request: PatchWorkoutRequest): Promise<Workout>;

    /**
     * @return A success message.
     */
    patchMoveWorkout(workoutId: string, position: number): Promise<Workout[]>;
}

export class WorkoutClient extends FetchBase implements IWorkoutClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return A success message.
     */
    getWorkouts(userId: string): Promise<Workout[]> {
        let url_ = this.baseUrl + "/User/{userId}/Workout";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWorkouts(_response);
        });
    }

    protected processGetWorkouts(response: Response): Promise<Workout[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Workout[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Workout[]>(null as any);
    }

    /**
     * @return A success message.
     */
    postWorkout(userId: string, workoutRequest: PostWorkoutRequest): Promise<Workout> {
        let url_ = this.baseUrl + "/User/{userId}/Workout";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workoutRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostWorkout(_response);
        });
    }

    protected processPostWorkout(response: Response): Promise<Workout> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Workout;
            return result201;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Workout>(null as any);
    }

    /**
     * @return A success message.
     */
    deleteWorkout(workoutId: string): Promise<void> {
        let url_ = this.baseUrl + "/Workout/{workoutId}";
        if (workoutId === undefined || workoutId === null)
            throw new Error("The parameter 'workoutId' must be defined.");
        url_ = url_.replace("{workoutId}", encodeURIComponent("" + workoutId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteWorkout(_response);
        });
    }

    protected processDeleteWorkout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return A success message.
     */
    getWorkout(workoutId: string): Promise<Workout> {
        let url_ = this.baseUrl + "/Workout/{workoutId}";
        if (workoutId === undefined || workoutId === null)
            throw new Error("The parameter 'workoutId' must be defined.");
        url_ = url_.replace("{workoutId}", encodeURIComponent("" + workoutId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWorkout(_response);
        });
    }

    protected processGetWorkout(response: Response): Promise<Workout> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Workout;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Workout>(null as any);
    }

    /**
     * @return A success message.
     */
    patchWorkout(workoutId: string, request: PatchWorkoutRequest): Promise<Workout> {
        let url_ = this.baseUrl + "/Workout/{workoutId}";
        if (workoutId === undefined || workoutId === null)
            throw new Error("The parameter 'workoutId' must be defined.");
        url_ = url_.replace("{workoutId}", encodeURIComponent("" + workoutId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPatchWorkout(_response);
        });
    }

    protected processPatchWorkout(response: Response): Promise<Workout> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Workout;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Workout>(null as any);
    }

    /**
     * @return A success message.
     */
    patchMoveWorkout(workoutId: string, position: number): Promise<Workout[]> {
        let url_ = this.baseUrl + "/Workout/{workoutId}/Move/{position}";
        if (workoutId === undefined || workoutId === null)
            throw new Error("The parameter 'workoutId' must be defined.");
        url_ = url_.replace("{workoutId}", encodeURIComponent("" + workoutId));
        if (position === undefined || position === null)
            throw new Error("The parameter 'position' must be defined.");
        url_ = url_.replace("{position}", encodeURIComponent("" + position));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPatchMoveWorkout(_response);
        });
    }

    protected processPatchMoveWorkout(response: Response): Promise<Workout[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Workout[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiError;
            return throwException("Description", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Workout[]>(null as any);
    }
}

export interface PreRegistrationResponse {
    icsUserId: string;
}

export interface PreRegistrationRequest {
    email: string;
}

export interface PostRegistrationRequest {
    icsUserId: string;
    providerIdentity: string;
}

export interface EquipmentGroupDto {
    equipmentGroupId: EquipmentGroupTypes;
    name: string;
    description: string;
}

export enum EquipmentGroupTypes {
    Invalid = 0,
    Barbell = 1,
    Cable = 2,
    Dumbbell = 3,
    Lever = 4,
    Sled = 5,
    Smith = 6,
    Band = 7,
    Suspension = 8,
    Calisthenics = 9,
}

export interface GetFilteredExercisesRequest {
    bodyAreaId: BodyAreaTypes;
    exerciseCount: number;
    excludeJoints: JointTypes[];
    excludeMuscles: MuscleTypes[];
    includeEquipmentGroups: EquipmentGroupTypes[];
}

export enum BodyAreaTypes {
    Invalid = 0,
    Upper = 100000,
    Core = 200000,
    Lower = 300000,
}

export enum JointTypes {
    Invalid = 0,
    Neck = 1,
    Shoulder = 2,
    Elbow = 3,
    Wrist = 4,
    UpperBack = 5,
    LowerBack = 6,
    Hip = 7,
    Knee = 8,
    Ankle = 9,
}

export enum MuscleTypes {
    Invalid = 0,
    Sternocleidomastoid = 111000,
    Splenius = 112000,
    AnteriorDeltoid = 121000,
    LateralDeltoid = 122000,
    PosteriorDeltoid = 123000,
    Supraspinatus = 124000,
    PectoralisMajor = 131000,
    PectoralisMinor = 132000,
    SerratusAnterior = 133000,
    LatissimusDorsi = 141000,
    Teres = 142000,
    Trapezius = 143000,
    LevatorScapulae = 145000,
    Rhomboids = 146000,
    Infraspinatus = 147000,
    Subscapularis = 148000,
    TricepsBrachii = 151000,
    BicepsBrachii = 152000,
    Brachialis = 153000,
    Brachioradialis = 161000,
    WristFlexors = 162000,
    WristExtendors = 163000,
    WristPronator = 164000,
    WristSupinator = 165000,
    QuadratusLumborum = 211000,
    ErectorSpinae = 212000,
    RectusAbdominis = 221000,
    TransverseAbdominis = 222000,
    Obliques = 223000,
    GluteusMaximus = 311000,
    Abductors = 312000,
    Flexors = 313000,
    Quadriceps = 321000,
    Hamstrings = 322000,
    Adductors = 323000,
    Gastrocnemius = 331000,
    Soleus = 332000,
    TibialisAnterior = 333000,
}

export interface BodyAreaDto {
    bodyAreaId: BodyAreaTypes;
    name: string;
    description: string;
    muscleGroupIds: MuscleGroupTypes[];
    muscleGroups?: MuscleGroupDto[] | null;
}

export enum MuscleGroupTypes {
    Invalid = 0,
    Neck = 110000,
    Shoulder = 120000,
    Chest = 130000,
    UpperBack = 140000,
    UpperArm = 150000,
    Forearm = 160000,
    LowerBack = 210000,
    Abdomen = 220000,
    Hip = 310000,
    Thigh = 320000,
    Calve = 330000,
}

export interface MuscleGroupDto {
    muscleGroupId: MuscleGroupTypes;
    name: string;
    description: string;
    bodyAreaId: BodyAreaTypes;
    bodyArea?: BodyAreaDto | null;
    jointIds: JointTypes[];
    joints?: JointDto[] | null;
    muscleIds: MuscleTypes[];
    muscles?: MuscleDto[] | null;
}

export interface JointDto {
    jointId: JointTypes;
    name: string;
    description: string;
    muscleGroupIds: MuscleGroupTypes[];
    muscleGroups?: MuscleGroupDto[] | null;
}

export interface MuscleDto {
    muscleId: MuscleTypes;
    name: string;
    description: string;
    muscleGroupId: MuscleGroupTypes;
    muscleGroup?: MuscleGroupDto | null;
}

export interface ApiResult {
    success: boolean;
}

export interface ApiError extends ApiResult {
    error: string;
}

export interface Routine {
    workoutId: string;
    routineId: string;
    position: number;
    exerciseId: ExerciseTypes;
    workout?: Workout | null;
    sets?: Set[] | null;
}

export enum ExerciseTypes {
    Invalid = 0,
    NeckFlexion = 111001,
    NeckExtension = 112001,
    FrontRaise = 113001,
    UprightRow = 114001,
    RearRow = 115001,
    FrontLateralRaise = 116001,
    ChestPress = 131000,
}

export interface Workout {
    workoutId: string;
    userId: string;
    position: number;
    name: string;
    user?: User | null;
    routines?: Routine[] | null;
}

export interface User {
    userId: string;
    workouts?: Workout[] | null;
}

export interface Set {
    routineId: string;
    setId: string;
    position: number;
    reps: number;
    weight: number;
    routine?: Routine | null;
}

export interface PatchRoutineRequest {
    exerciseId: ExerciseTypes;
}

export interface PostSetRequest {
    reps: number;
    weight: number;
}

export interface PatchSetRequest {
    reps: number;
    weight: number;
}

export interface PostWorkoutRequest {
    name: string;
    routines?: PostRoutineRequest[] | null;
}

export interface PostRoutineRequest {
    exerciseId: ExerciseTypes;
    sets?: PostSetRequest[] | null;
}

export interface PatchWorkoutRequest {
    name: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}